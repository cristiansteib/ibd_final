Resumen de arboles
========================

* *Archivos de datos vs. índices de datos*
	* Supongamos que necesitamos realizar búsquedas de información por código de cliente, por nombre de cliente, por tarjeta de identificaciòn o por fecha de nacimiento, indistintamente. ¿ Por que criterio se debe ordenar el archivo ? Cómo los cuatro ordenamientos son necesarios, se generarán cuatro archivos (organizados como árboles binarios) diferentes, cada estructura ordenada sólo necesita el atributo por el cual se ordena, de éste modo se debe separar el archivo de datos de los índices de dicho archivo. El archivo de datos se trata como un archivo serie, dónde cada elementos es insertado al final del archivo y no hay orden físico de los datos. Cada archivo de índice tendrá entonces la siguiente estructura: el índice, los punteros a los hijos del nodo y y la direccin (NRR) del registro completo en el archivo de datos.
* *Árbol binario*
	* Un árbol binario es una estructura de datos dinámica no lineal, en la cual cada no puede tener a lo sumo dos hijos. Èsta estructura en genera lsólo tiene sentido cuando está ordenado, esto es, a la izquierda de un elemento se encuentran los elementos menores que él y a la derecha los mayores. Por éste motivo la búsqueda de información de un árbol binario es de orden logaritmico (cantidad de accesos al disco) ya que la misma en un árbol binario comienza siempre desde la raíz y eb cada revisiòn se descarta la mitad del archivo restante.
	Una ventaja de los árboles binarios frente a archivos que no poseen ésta organización está dada en la *inserción de nuevos elementos*. Mientras los primeros se desordenan frente a un inserción y reordenarlo resulta muy costoso, los segundos pueden mantenerse ordenados de manera mucho menos costosa, encontrando al padre del elemento (lo que implicara Log(N) lecturas) y dos operaciones de escritura (el nuevo elemento y la actualización del padre). De forma similar cuando se *borra un elemento* de necesitan Log(N) lecturas para encontrar al padre y dos escrituras para eliminar el nodo. Cómo conclusión los árboles binarios representan una buena elección en términos de inserción y borrado de elementos.
	Pero *los árboles binarios también presentan problemas*, *el desempeño en la búsqueda en un árbol binario es bueno cuándo éste está balanceado*, el caso degenerado de un árbol binario transforma al mismo en una estructura de tipo lista y, en ese caso, la performance de búsqueda decae, transofrmándose en orden lineal, por lo tanto el árbol binario sólo resulta una buena organización para un archivo de índices cuándo éste está balanceado. La correcta elección de la raíz del ´arbol determinará si el mismo permanecerá balanceado o no, el problema es que cuando se genera un archivo que implanta un índice de búsqueda, es imposible a priori determinar cuál es la mejor raíz, dado que dependerá de los elementos de datos que se inserten.
* Árbol balanceado en altura
	* Un árbol balanceado es aquel donde la trayectoria de la raíz a cada una de las hojas está representada por igual cantidad de nodos. Es decir, todos los nodos hoja se encuentran a igual distancia del nodo raíz.
* *Árbol AVL*
	* Los arboles binarios balanceados en altura son árboles cuya construcción se determina respetando un precepto muy simple: la diferencia entre el camino más corto y el más largo entre un nodo terminal y la raíz no puede diferir en más de un determinado delta, y dicho delta es el nivel de balanceo en altura del árbol. Así un árbol AVL es un árbol balanceado en altura dónde el delta determinado es uno, es decir, el máximo desbalanceo posible es uno. El algoritmo que matiene el balanceo del árbol frente a inserciones o borrados es relativamente sencillo pero los costos computacionales de acceso a disco aumenta condiferablemente por lo cual su implementación deja de ser viable.
* Conclusiones sobre la performance de árboles binarios y AVL
	* Son estructuras capaces de mantener balanceo acotado, pero asumiendo mayores costos en las operaciones de inserción y borrado por lo cual no son una solución viable para los índices de los archivos de datos.
* Paginación de árboles binarios
	* Cuándo se accede al disco para transferir datos no se transfieren unos pocos bytes, sino que se transmite una página completa, cada página contiene un conjunto de nodos, os cuales están ubicados en direcciones físicas cercanas. Un árbol dividido en páginas permite realizar búsquedas más rápidas en memoria secundaria. Así, suponiendo que en un buffer caben 255 elementos, el tamaño de cada página sería entonces de 255 nodos, resultando la performance final de búsqueda del orden log256(N), es decir, logK+1(N), siendo N la cantidad de claves dle archivo y K la cantidad de nodos por página. Pero dividir un árbol en páginas implica un costo extra necesario para su reacomodamiento y para mantener su balanceo interno. Un algoritmo que soporta ésta construcción será muy costoso de implementar y luego también en cuanto a performance.
* Árboles multicamino
	* Un árbol multicamino es una estructura de datos en la cual cada nodo puede contener k elementos y k+1 hijos, el orden del árbol multicamino es la máxima cantidad de descendientes posibles de un nodo. Ahora, se podría pensar en un árbol multicamino dónde su orden sea la cantidad de nodos que entran en una página, ésto permitirá obtener árbol mucho más bajos.
* Familia de árboles B
	* Los árboles B son árboles son árboles multicamino con una construcción especial, que permite mantenerlos balanceados a bajo costo. Un árbol B de orden M posee las siguientes propiedades básicas:
		1. Cada nodo del árbol puede contener, cómo máximo, M descendientes y M - 1 elementos.
		2. La raiz no posee desecendientes directos o tiene al menos dos. *En ningún caso la raíz puede tener un solo descendiente*
		3. Un nodo con x descendientes directos contiene x-1 elementos.
		4. Los nodos terminales tiene, cómo mínimo, M/2 - 1 elementos, y cómo máximo M - 1
		5. Los nodos que no son hoja ni raíz tienen, cómo mínimo M/2 elementos.
		6. Todos los nodos hojas se encuentran al mismo nivel. Èsta restricción permite concluir que la performance de un árbol B será respetada sin importar cómo se construya el árbol, es decir, sin importar el orden de llegada de los elementos.
	* Los arboles B crencen en altura, es decir, es la raíz la que  se aleja de los nodos terminales, de modo tal que siempre el árbol crezca de manera balanceada.
	* La eficiencia en la búsqueda en un árbol B consiste en contar los accesos al archivo de datos, que se requieren para localizar un elemento o para determinar que el elemento no se encuentra. El resultado es un valor acotado en el rango entero de [1,H], siendo H la altura del árbol. En caso de localizar al elemento en un nodo terminal (o que el elemento no se ecuentre) serán requeridos H accesos. La performance de la operación de inserción está dada por H lecturas y una escritura en el mejor de los casos o (2 * H) + 1 escrituras en el peor, ésto es, cuándo se produce overflow en el nodo dónde se inserta el elemento y el overflow se propaga hacía la raíz. La inserción require un número considerablemente bajo de operaciones de ES para mantener el orden de la estructura. Para poder borrar un elemento éste debe estar ubicado en un nodo terminal, cuándo éste es eliminado se pueden dar dos situaciones, que se genere un underflow o que no se genere, cuando no lo hace no hay problema, pero cuando si, es decir cuándo el nodo deja de cumplir con la condición de contener al menos [M/2] - 1, es necesario llevar a cabo algún tipo de acción para corrregir la situación, tratando de afectar la menor cantidad de nodos posible para mantener los cambios acotados, y por ende, la eficiencia del proceso. Una alternativa posible es la de redistrubuir los elementos entre el padre y los nodos adyacentes, de ésta menra el cambio sólo afecta a éstos y no se propaga a través del árbol. no obstante no siempre es posible realizar una redistribución ya que para ésto se debe dìsponer de un nodo adyacente hermano con suficientes elementos para compartir, en ese caso la única alternativa posible es la de concatenar los nodos y eliminar al padre, ya que no será necesario la separación, la desventaja es que la concatenación puede propagar cambios a lo largo del árbol. En definitiva en el mejor de los casos se necesatarán H lecturas y sólo una escritura para realizar un borrado, mientras que en el peor se deberá concatenar en todos los niveles, por cada nivel que se concatene habrá dos lecturas, salvo en el nodo raíz, el cual carece hermanos. la cantidad de escrituras se limita entonces a una por nivel; entonces se puede concluir que la operación de borrado resulta muy beneficiosa
* Conclusiones sobre los árboles B
	* Los arboles balanceados representan una buena solución como estrutura de datos para implementar el manejo de índices asoaciados a archivos de datos.
	* Cualquier operación se realiza en términos aceptables de performance.
	* Se debe tener en cuenta que los árboles B serán utilizadas para administrar los *índices* asociados a claves primarias, candidatas o secundarias. Los índices secundarios y de claves candidatas referencian a la clave primaria en lugar de al archivo de datos, esto se debe a que en caso de modificar la posición física de un registro, sólo se debe modificar un índice, el correspondiente a la clave primaria.
* Árboles B*
	* Los àrboles B* representan una variable de los árboles B en la que se modifica el proceso de inserción, en lugar de realizarse directamente una divisiòn siempre que se produzca overflow (lo cual siempre genera nuevos nodos) see intentará redistribuir por lo que se demorará la generación de nuevos nodos y por ende el árbol crecerá en altura de forma más lenta lo que trae aparejado una mejor performance. Aplicando la redistribución, cuándo un nodo se completa, reubica sus elementos utilizando un nodo adyacente hermano y cuando ésto no sea posible, dado que tanto el nodo que genera el overflow como su hermano estan completos, se puede dividir partiendo de dos nodos completos, lo que resulta en tres nodos con dos tercios completos cada uno, es decir que el aspecto más notable es que genera nods completos en 2/3 partes en lugar de nodos llenos hasta la mitad.
	* Un árbol B posee las siguientes propiedades:
		* Cada nodo del árbol puede contener, como máximo, M descendientes y M - 1 elementos.
		* La raíz no posee descendientes o tiene al menos dos.
		* Un nodo con X descendientes contiene x - 1 elementos.
		* Los nodos hojas tienen como mínimo (2M-1)/3 - 1 elementos.
		* Los nodos que no son términales ni raíz tienen como mínimo (2M-1)/3 elementos.
		* Todos los nodos hoja se encuentran al mismo nivel.
	* La única excepción en el tratamiento de árboles B* se produce cuándo se completa el primer nivel del árbol, ya que la raíz no tiene hermanos no es posible redistribuir por lo cual al dividir, los dos nodos hijos generados estarán llenos a la mitad en lugar de en 2/3.
	* El proceso de inserción puede ser regulado de acuerdo a 3 políticas básicas:
		* Política de un lado.
		* Política de un lado *u* otro lado.
		* Política de un lado *y* otro lado.  
		Cada política determina, en caso de overflow, el nodo adyacente hermano a tener en cuenta.  
		Cuándo se utiliza la política de un lado se debe elegir que lado se utilizará (izquierda o derecha), cuando un nodo no posee un hermano a la izquierda, y se usa la política de un lado a la izquierda, se podrá utilizar el nodo de la derecha, pero sólo en éste caso y viceversa.
		Cuándo se utiliza la política de *un lado u otro*, se puede utilizar cualquiera de los dos hermanos adyacentes.  
		Cuándo se utiliza la política de *un lado y otro*, se puede utilizar cualquiera de los dos hermanos adyacentes, la diferencia con la política anterior radica en que a la hora de la división, si la redistribución no fue posible, se utilizarán los tres nodos, en lugar de los dos hermanos adyacentes como en el caso anterior.
	* Si bien los árboles B* generan árboles de menor altura se necesita de un mayor número de operaciones de entrada-salida sobre disco para poder ser implementada.
	* Performance en la inseción
		* La performance resultando de la inserción sobre árboles B* dependerá de cada política, Así, ante la ocurriencia de overflow, como mínimo cada una de las políticas require dos lecturas (el nodo que se satura y un adyacente hermano) y tres escrituras (cada nodo hijo y el padre). En caso de realizar una división tanto la política de un lado como la política de un lado u otro lado necesita cuatro escrituras, la política de un lado y otro lado generan cinco escrituras.
* Acceso secuencial indizado
	* Se denomina archivo con acceso secuencial indizado a auqle que permite dos formas para visualizar la información:
		* Indizada
		* Secuencial  
	Para recuperar los N registros en orden es necesario recorrer todos los nodos del árbol a través de los punteros definidos. Esto significa acceder a un nodo hoja, volver a su padre, acceder al nodo hoja siguiente y asi. Si el archivo require mucho acceso secuencial utilizando el índice la solución resulta muy ineficiente. Por otro lado, si se plantea la alternativa de mantener el archivo físico ordenado, se soluciona el problema pero resulta inaceptable al momento de acceder para recuperar un dato, realizar una inserción o eliminación.
* Árboles B+
	* El árbol B+ incorpora las caracteristicas del árbol B y además para el tratamiento secuencial ordenado del archivo, para ello los nodos terminales representan un conjunto de datos y son entrelazados entre ellos, entonces, todos los elementos están almacenados en un nodo terminal, así los arboles B+ diferencian los elementos que constituyen datos de los separadores. Al comenzar la creación de un árbol B+, el único nodo disponible, la raíz, actúa tanto como punto de partida para búsquedas como para acceso secuencial. Cuándo se produce una división el elemento promocionado es una copia (la del menor de los elementos mayores) y no el elemento en sí; en caso de dividir una nodo no terminal si se promociona el elemento en si y no una copia. A la hora de borrar un elemento en un árbol B+ se debe borrar siempre el elemento de la hoja, y si el dato fuera un separador el mismo se mantendría ya que aún sería un separador válido.
* Àrboles B+ de prefijos siemples
	* Un árbol B+ de prefijos simples es un árbol B+ dónde los separadores están representados por mínima expresión posible de la clave que ṕermita decidir si la búsqueda se realiza hacía la izquierda o la derecha. Los prefijos intentan aprovechar mejor el espacio físico.
* Conclusiones sobre árboles balanceados
	* Los árboles balanceados son estructuras muy poderosas y flexibles para la administración de índices asociados a archivos de datos, con un nivel de performance muy interesante. Sin embargo no deben considerarse como la única solución posible a todos los problemas. La mejor solución para un archivo va a depender del archivo en sí y del propósito de uso de dicho archivo. Por ejemplo si el archivo es pequeño no es necesario, ni aconsejable, utilizar un árbol, ya que el mismo agrega un nivel de indirección por cada índice generado. Las caracteristicas compartidas por la familia de árboles B son:
		* Manejo de bloques o nodos lo que facilita el manejo de entrada-salida y disminuye la cantidad de accesos a disco.
		* Están balanceados.
		* Crecren de abajo hacía arriba.
		* Son bajos y anchos.
		* Es posible implementar archivos de longitud variable para mejorar performance y uso de espacio.
	En particular los árboles B* mejoran la eficiencia de los árboles B, aumentando la cantidad mínima de elementos en cada nodo, el costo es que las operaciones de inserción resultan un poco más lentas.
	En los árboles B+ toda la información está contenida en los nodos terminales.
